ordinateur : on %%%%%%%%%%, >>> no devices connected

-- on branche le cube --

ordinateur : on %%%%%%% >>> there are ** devices connected, choose one
>> idDevice enregistré

ordinateur : on choisit le cube => on envoie un message (DataMessage ou nouvelle classe à définir) pour demander "qui es-tu ?"

SI NOUVELLE CLASSE, MESSAGE AVEC 1 BUFFER
cube :
     - si je ne recois pas le message : {ref 1}
     - si je recois un message :
          -- je check si idDevice = myID && opCode € (BUFF_SENDING, LIGHT_SENDING, FIRMWARE_SENDING, TFT_SENDING), si ce n'est pas le cas : je ne lis même pas le message              
          -- je check le CRC :
                --- s'il est faux => j'envoie ACK_ERR
                --- s'il est juste :
                         ---- je check le header, si 1 OK (dans ce cas), sinon PAS OK => j'envoie ACK_NOK (avec l'idBuffer que j'veux recevoir, pour savoir : je lis opCode et sizeLeft)
                                                                         ici, j'aurais pas recu le premier paquet : ACK_NOK(0,0)
                         ---- je traite le message, ie je lis le buffer 
                                 sizeLeft < sizeBuffer de ce type d'opCode ?? ici oui donc message fini (oui oui composé que de 1 buffer)
                                 Comme il s'agit d'un message "qui es-tu ?",
                                 => je dois renvoyer un message (de même type, donc 1 buffer) avec mes attributs pour l'instant sizeX, sizeY, sizeZ

ordinateur :
     - si on ne recoit rien :
          -- {ref 1}, le cube n'avait pas reçu mon message de base => TIMEOUT à implémenter puis, revérifier si le cube est toujours connecté ou pas
          -- on ne recoit pas le message du cube => TIMEOUT
     - si on recoit un message : (on copie ce qu'il se passe sur firmware ???)
          -- on check le CRC :
                --- s'il est faux => je renvoie ma demande initial (POURQUOI ? compromis : si je renvoyais des ack, j'enverrai de plus petit buffer,
                                                                                         mais il faudrait que le cube garde en mémoire des trucs, trop complexe)
                --- s'il est juste :
                         ---- on check s'il vient bien de idDevice, si non : ciao
                         ---- on check le header, si 1 OK, sinon : ciao (le TIMEOUT reposera la question plus tard, au bout de 5 TIMEOUT => cube.available() ?)
                         ---- on traite le message, ie je lis le buffer : opCode et sizeLeft
                              ----- le message est-il fini ? sizeLeft < sizeBuffer(opCode)
                                    si non : j'attends le suite du message                              
                                    si oui, je lis le opCode :
                                            ------ si c'est un ACK_ERR || un ACK_NOK => je renvoie le buffer demandé (0,0 == buffer n°1) (compteur ++, au bout de 3 essais, on arrête)
                                            ------ si c'est un opCode € reponse_possible(opCode de "qui es-tu ?") : on est content
                                                      >> sizeX, sizeY, sizeZ enregistrés
                                                   sinon => je renvoie mon message d'avant (compteur ++, au bout de 3 essais, on arrête)

-- je débranche le cube --

ordinateur :
    - on veut demander les états des LEDs du cube => j'envoie un message (Message de type question avec l'idDevice et l'opCode qu'il faut)
    %%%%% ???
    >>> this device is no longer available
